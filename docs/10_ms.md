# SQS, SNS, and EventBridge

These services enable **eventâ€‘driven, decoupled, reliable** architectures at scale.

***

# ğŸ§  **SECTION 1: Overview â€” What Each Service Does**

## **1. Amazon SQS â€” Queue Service (Decouple + Buffer Workloads)**

*   Reliable message queue
*   Enables async processing
*   Prevents system overload
*   Guarantees delivery at least once
*   Supports FIFO queues for ordering

Use cases:

*   Async Lambda processing
*   Offloading heavy processing
*   Buffering API requests

***

## **2. Amazon SNS â€” Pub/Sub Notifications (Fanâ€‘out)**

*   Publish events to multiple consumers
*   Supports email, Lambda, SQS, HTTPS endpoints

Use cases:

*   Send messages to multiple systems
*   Alerts, notifications
*   App-wide broadcast events

***

## **3. Amazon EventBridge â€” Event Bus (Rules + Routing)**

*   Serverless event routing
*   Scheduling (Cron)
*   Crossâ€‘service automation
*   Decoupled event-driven patterns

Use cases:

*   Cron jobs
*   Orchestration
*   Multi-service communication
*   Audit & compliance automation

***

# ------------------------------------

# ğŸ§ª \*\*SECTION 2: Handsâ€‘On Exercise #1

Amazon SQS â€” Build a Reliable Processing Queue\*\*

### **Goal:**

API Gateway â†’ Lambda â†’ SQS â†’ Worker Lambda (async processing)

***

## **Step 1 â€” Create an SQS Queue**

SQS â†’ Create Queue

Name:

    orders-processing-queue

Type:

    Standard

Enable:

*   Visibility timeout: 30 sec
*   Message retention: 4 days

***

## **Step 2 â€” Create Producer Lambda**

Name:

    queue-producer-lambda

Code (Node.js):

```javascript
const AWS = require("aws-sdk");
const sqs = new AWS.SQS();

exports.handler = async (event) => {
  const params = {
    QueueUrl: process.env.QUEUE_URL,
    MessageBody: JSON.stringify(event)
  };

  await sqs.sendMessage(params).promise();

  return { statusCode: 200, body: "Message sent to SQS" };
};
```

Environment variable:

    QUEUE_URL = https://sqs-region.amazonaws.com/account-id/orders-processing-queue

***

## **Step 3 â€” Create Consumer Lambda**

Name:

    queue-worker-lambda

Add SQS trigger:

*   Choose your queue
*   Batch size: 1

Worker code:

```javascript
exports.handler = async (event) => {
  event.Records.forEach(record => {
    console.log("Message received:", record.body);
  });
};
```

***

### ğŸ¯ **Outcome:**

You now have a full **SQS queue processing pipeline**.

***

# ------------------------------------

# ğŸ§ª \*\*SECTION 3: Handsâ€‘On Exercise #2

Amazon SNS â€” Fanâ€‘Out Pattern to Multiple Services\*\*

### **Goal:**

Publish one event â†’ trigger multiple downstream consumers.

***

## **Step 1 â€” Create SNS Topic**

SNS â†’ Create Topic â†’ Standard

Name:

    order-events-topic

***

## **Step 2 â€” Create Subscriptions**

Add subscribers:

### Subscriber #1

Lambda â†’ `order-lambda-handler`

### Subscriber #2

SQS â†’ `order-processing-queue`

### Subscriber #3

Email â†’ `you@company.com`

***

## **Step 3 â€” Publish a Message**

From SNS console:

    Order Created: {"orderId":"O1111"}

Your subscribers will process the message **simultaneously**.

***

### ğŸ¯ **Outcome:**

SNS now broadcasts events reliably across multiple services.

***

# ------------------------------------

# ğŸ§ª \*\*SECTION 4: Handsâ€‘On Exercise #3

EventBridge â€” Serverless Scheduling + Event Routing\*\*

EventBridge is powerful because it supports:

*   cron schedules
*   event patterns
*   routing to 20+ AWS services

***

## **Use Case #1: Scheduled Lambda (Cron Job)**

### **Step 1 â€” Create Rule**

EventBridge â†’ Create Rule

Name:

    hourly-cleanup

Pattern:

    Schedule
    cron(0 * * * ? *)   # every hour

***

### **Step 2 â€” Add Target**

Target:

    Lambda â†’ cleanup-lambda

***

### ğŸ¯ **Outcome:**

Your Lambda runs every hour.

***

## **Use Case #2: Event Routing (DynamoDB â†’ EventBridge â†’ Lambda)**

### **Flow:**

DynamoDB Streams â†’ EventBridge â†’ Lambda

***

## **Step 1 â€” Create Event Pattern**

EventBridge â†’ Create Rule

Pattern matching:

```json
{
  "source": ["aws.dynamodb"],
  "detail-type": ["DynamoDB Update"]
}
```

***

## **Step 2 â€” Target**

Lambda â†’ `dynamodb-event-processor`

***

### ğŸ¯ **Outcome:**

EventBridge listens to DynamoDB events and routes them.

***

# ------------------------------------

# ğŸ§  **SECTION 5: Real-World Patterns Using SQS, SNS, EventBridge**

These appear in nearly every enterprise system.

***

## **Pattern 1: API Traffic Buffering (Protect Lambda)**

    API Gateway â†’ Lambda â†’ SQS â†’ Worker Lambda

Purpose:

*   prevent spikes
*   ensure all jobs complete
*   improve reliability

***

## **Pattern 2: SNS Fanâ€‘Out Across Microservices**

    OrderService â†’ SNS â†’ Lambda A
                           â†’ SQS B
                           â†’ Email C
                           â†’ Analytics D

Purpose:

*   event-driven microservices
*   decoupling
*   no tight dependencies

***

## **Pattern 3: EventBridge Cross-Service Automation**

    S3 Upload â†’ EventBridge â†’ Step Functions â†’ Lambda

***

## **Pattern 4: Central Event Bus for Distributed Apps**

    App1 â†’ EventBridge Bus â†’ Targets
    App2 â†’ EventBridge Bus â†’ Targets
    App3 â†’ EventBridge Bus â†’ Targets

***

# ------------------------------------

# ğŸ” **SECTION 6: Best Practices (Productionâ€‘Ready)**

## **SQS**

âœ” Use deadâ€‘letter queues (DLQs)  
âœ” Set appropriate visibility timeout  
âœ” Avoid large payloads (>256KB)  
âœ” Use batch window for high throughput

***

## **SNS**

âœ” Use message filtering to reduce noise  
âœ” Never send PII in SNS payload  
âœ” Use encryption (KMS)  
âœ” Donâ€™t directly connect external consumers â†’ use HTTPS endpoints with auth

***

## **EventBridge**

âœ” Prefer EventBridge over SNS+SQS for complex routing  
âœ” Name events clearly and consistently  
âœ” Validate events in consumers  
âœ” Use AWS Schema Registry

***

# ------------------------------------

# ğŸ“ **SECTION 7: Stepâ€‘10 Final Assignment (Mini Project)**

Build a complete event-driven pipeline combining **all 3 services**.

***

# ğŸ§ª **Architecture**

    API Gateway
         â†“
     Lambda (producer)
         â†“
         SQS Queue
         â†“
     Worker Lambda
         â†“           â†’ SNS Topic â†’ Email alerts
         â†“
    EventBridge (audit event)
         â†“
    Lambda (audit processor)

***

## **Your Tasks**

1ï¸âƒ£ Create SQS queue (orders-queue)  
2ï¸âƒ£ Create Lambda producer to push messages to SQS  
3ï¸âƒ£ Create worker Lambda to process order messages  
4ï¸âƒ£ Create SNS topic â€œorder-eventsâ€  
5ï¸âƒ£ Worker Lambda publishes â€œOrder Processedâ€ messages to SNS  
6ï¸âƒ£ Add email + SQS subscriptions to SNS  
7ï¸âƒ£ Create EventBridge rule to capture all â€œOrder Processedâ€ events  
8ï¸âƒ£ Send them to an audit Lambda  
9ï¸âƒ£ Build a CloudWatch dashboard visualizing:

*   SQS queue depth
*   Lambda errors
*   SNS deliveries
*   EventBridge execution counts

***

### ğŸ¯ **End Result:**

You now understand all **supporting AWS messaging services** that power realâ€‘world serverless architectures.

***